#-*- coding: utf8 -*-
'''
Faraday Penetration Test IDE
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from StringIO import StringIO
from tempfile import NamedTemporaryFile

import os
from base64 import b64encode

import pytz
from hypothesis import given
from hypothesis.strategies import text, lists, integers, one_of, none

from test_cases.conftest import ignore_nplusone

try:
    from urllib import urlencode
except ImportError:
    from urllib.parse import urlencode

import pytest
import time
from hypothesis import given, strategies as st

from server.api.modules.vulns import (
    TypeFilter,
    VulnerabilityFilterSet,
    VulnerabilitySchema,
    VulnerabilityView
)
from server.schemas import NullToBlankString
from test_cases import factories
from test_api_workspaced_base import (
    ReadOnlyAPITests
)
from server.models import (
    VulnerabilityGeneric,
    Vulnerability,
    VulnerabilityWeb,
    Reference, PolicyViolation, CommandObject)
from test_cases.factories import ServiceFactory, CommandFactory, \
    CommandObjectFactory, HostFactory, EmptyCommandFactory, \
    UserFactory, VulnerabilityWebFactory, VulnerabilityFactory, \
    ReferenceFactory, PolicyViolationFactory, HostnameFactory, WorkspaceFactory

CURRENT_PATH = os.path.dirname(os.path.abspath(__file__))


def _create_post_data_vulnerability(name, vuln_type, parent_id,
                                    parent_type, refs, policyviolations,
                                    status='opened',
                                    attachments=None, impact=None,
                                    description='desc1234',
                                    confirmed=True, data='data1234',
                                    easeofresolution=
                                    Vulnerability.EASE_OF_RESOLUTIONS[0],
                                    owned=False, resolution='res1234',
                                    severity='critical',
                                    update_controller_action='UI Web'
                                    ):
    if not impact:
        impact = {'accountability': False, 'availability': False,
                  'confidentiality': False,
                  'integrity': False}
    data = {
        'metadata': {
            'update_time': 1508254070.211,
            'update_user': '',
            'update_action': 0,
            'creator': 'UI Web',
            'create_time': 1508254070.211,
            'update_controller_action': update_controller_action,
            'owner': ''},
        'obj_id': '5a60af7f01dde6d3acfa8e9d3bef265c361a49d2',
        'owner': '',
        'parent': parent_id,
        'parent_type': parent_type,
        'type': vuln_type,
        'ws': 'airbnb',
        'confirmed': confirmed,
        'data': data,
        'desc': description,
        'easeofresolution': easeofresolution,
        'impact': impact,
        'name': name,
        'owned': owned,
        'policyviolations': policyviolations,
        'refs': refs,
        'resolution': resolution,
        'severity': severity,
        'status': status,
        '_attachments': {},
        'description': '',
        'protocol': '',
        'version': ''}

    if vuln_type == 'VulnerabilityWeb':
        data.update({
            "method": "GET",
            "params": "pepe",
            "path": "/pepep",
            "pname": "pepe",
            "query": "queue&dfsa",
            "request": "",
            "response": "",
            "website": "www.pepe.com"})

    if attachments:
        data['_attachments'] = {}
        for attachment in attachments:
            data['_attachments'][attachment.name] = {
                "content_type": "application/x-shellscript",
                "data": b64encode(attachment.read())
            }

    return data


@pytest.mark.usefixtures('logged_user')
class TestListVulnerabilityView(ReadOnlyAPITests):  # TODO migration: use read write api tests
    model = Vulnerability
    factory = factories.VulnerabilityFactory
    api_endpoint = 'vulns'
    #unique_fields = ['ip']
    #update_fields = ['ip', 'description', 'os']
    view_class = VulnerabilityView

    def test_backward_json_compatibility(self, test_client, second_workspace, session):
        self.factory.create(workspace=second_workspace)
        session.commit()
        res = test_client.get(self.url())
        assert res.status_code == 200
        assert 'vulnerabilities' in res.json
        for vuln in res.json['vulnerabilities']:
            assert set([u'id', u'key', u'value']) == set(vuln.keys())
            object_properties = [
                u'status',
                u'issuetracker',
                u'description',
                u'parent',
                u'tags',
                u'severity',
                u'_rev',
                u'easeofresolution',
                u'owned',
                u'hostnames',
                u'pname',
                u'query',
                u'owner',
                u'path',
                u'data',
                u'response',
                u'refs',
                u'desc',
                u'impact',
                u'confirmed',
                u'name',
                u'service',
                u'obj_id',
                u'type',
                u'policyviolations',
                u'request',
                u'_attachments',
                u'target',
                u'_id',
                u'resolution',
                u'method',
                u'metadata',
                u'website',
                u'params',
            ]
            expected = set(object_properties)
            result = set(vuln['value'].keys())
            assert expected - result == set()

    def test_handles_vuln_with_no_creator(self,
                                          workspace,
                                          test_client,
                                          session):
        # This can happen when a user is deleted but its objects persist
        vuln = self.factory.create(workspace=workspace, creator=None)
        session.add(vuln)
        session.commit()
        res = test_client.get(self.url(vuln))
        assert res.status_code == 200
        assert res.json['owner'] is None

    def test_shows_policy_violations(self, workspace, test_client, session,
                                     policy_violation_factory):
        pvs = policy_violation_factory.create_batch(
            5, workspace=workspace)
        for pv in pvs:
            self.first_object.policy_violation_instances.add(pv)
        session.add(self.first_object)
        session.commit()
        res = test_client.get(self.url(self.first_object))
        assert res.status_code == 200
        assert len(res.json['policyviolations']) == 5
        assert set(res.json['policyviolations']) == {pv.name for pv in pvs}

    def test_shows_refs(self, workspace, test_client, session,
                        reference_factory):
        refs = reference_factory.create_batch(
            5, workspace=workspace)
        for ref in refs:
            self.first_object.reference_instances.add(ref)
        session.commit()
        res = test_client.get(self.url(self.first_object))
        assert res.status_code == 200
        assert len(res.json['refs']) == 5
        assert set(res.json['refs']) == {ref.name for ref in refs}

    @pytest.mark.parametrize('creator_func', [
        (lambda host: factories.VulnerabilityFactory.create(
            workspace=host.workspace, host=host, service=None)),
        (lambda host: factories.VulnerabilityFactory.create(
            workspace=host.workspace, host=None,
            service=factories.ServiceFactory.create(
                workspace=host.workspace, host=host
            ))),
        (lambda host: factories.VulnerabilityWebFactory.create(
            workspace=host.workspace, service=factories.ServiceFactory.create(
                workspace=host.workspace, host=host
            ))),
    ], ids=['standard_vuln_with_host', 'standard_vuln_with_service',
            'web_vuln_with_service'])
    def test_hostnames(self, host_with_hostnames, test_client, session,
                       creator_func):
        vuln = creator_func(host_with_hostnames)
        vuln = self.factory.create(host=host_with_hostnames,
                                   service=None,
                                   workspace=host_with_hostnames.workspace)
        session.commit()
        res = test_client.get(self.url(vuln))
        assert res.status_code == 200
        assert isinstance(res.json['hostnames'], list)
        assert set(res.json['hostnames']) == set(hostname.name for hostname in
                                                 host_with_hostnames.hostnames)
    def test_create_vuln(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['name'] == 'New vulns'
        assert res.json['type'] == 'Vulnerability'
        assert res.json['parent'] == host_with_hostnames.id
        assert res.json['parent_type'] == 'Host'
        assert res.json['desc'] == 'helloworld'
        assert res.json['description'] == 'helloworld'
        assert res.json['severity'] == 'low'

    def test_create_cannot_create_vuln_with_empty_name_fails(
            self, host, session, test_client):
        # I'm using this to test the NonBlankColumn which works for
        # all models. Think twice before removing this test
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='',
            vuln_type='Vulnerability',
            parent_id=host.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='aaa',
            severity='low',
        )
        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 400
        assert 'Shorter than minimum length 1' in res.data

    def test_create_create_vuln_with_empty_desc_success(
            self, host, session, test_client):
        # I'm using this to test the NonBlankColumn which works for
        # all models. Think twice before removing this test
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='Empty desc',
            vuln_type='Vulnerability',
            parent_id=host.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='',
            severity='low',
        )
        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 201

    def test_create_vuln_with_attachments(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        attachment = NamedTemporaryFile()
        file_content = 'test file'
        attachment.write(file_content)
        attachment.seek(0)
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
            attachments=[attachment]
        )

        res = test_client.post(self.url(), data=raw_data)
        vuln_id = res.json['_id']
        assert res.status_code == 201
        filename = attachment.name.split('/')[-1]
        assert filename in res.json['_attachments']
        attachment.close()
        # check the attachment can be downloaded
        res = test_client.get(self.url() + '{0}/attachment/{1}/'.format(vuln_id, filename))
        assert res.status_code == 200
        assert res.data == file_content

        res = test_client.get(
            self.url() +
            '{0}/attachment/notexistingattachment.png/'.format(vuln_id))
        assert res.status_code == 404

    @ignore_nplusone
    def test_update_vuln_add_attachment_on_update(self, test_client, session):
        host = HostFactory.create(workspace=self.workspace)
        vuln = VulnerabilityFactory.create(workspace=self.workspace, host_id=host.id)
        session.commit()  # flush host_with_hostnames
        attachment = NamedTemporaryFile()
        file_content = 'test file'
        attachment.write(file_content)
        attachment.seek(0)
        raw_data = self._create_put_data(
            'Updated with attachment',
            'Updated vuln',
            'open',
            host.id,
            'Host',
            attachments=[attachment]
        )
        res = test_client.put(self.url(obj=vuln, workspace=self.workspace), data=raw_data)
        assert res.status_code == 200
        filename = attachment.name.split('/')[-1]
        res = test_client.get(
            self.url() + '{0}/attachment/{1}/'.format(vuln.id, filename))
        assert res.status_code == 200
        assert res.data == file_content

        new_attachment = NamedTemporaryFile()
        new_filename = new_attachment.name.split('/')[-1]
        file_content = 'new test file'
        new_attachment.write(file_content)
        new_attachment.seek(0)
        res = test_client.put(self.url(obj=vuln, workspace=self.workspace),
                              data=raw_data)
        assert res.status_code == 200

        # verify that the old file was deleted and the new one exists
        res = test_client.get(
            self.url() + '{0}/attachment/{1}/'.format(vuln.id, filename))
        assert res.status_code == 404
        res = test_client.get(
            self.url() + '{0}/attachment/{1}/'.format(vuln.id, new_filename))
        assert res.status_code == 200
        assert res.data == file_content



    def test_create_vuln_props(self, host_with_hostnames, test_client, session):
        """
        This one should check all the vuln props that don't have a specific case
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        vuln_props = {
            'confirmed': False,
            'data': 'hellodata',
            'easeofresolution': Vulnerability.EASE_OF_RESOLUTIONS[0],
            'owned': True,
            'resolution': 'helloresolution',
            'status': 'closed'
        }
        vuln_props_excluded = ['owned']
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
            **vuln_props
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        for prop, value in vuln_props.iteritems():
            if prop not in vuln_props_excluded:
                assert res.json[prop] == value, prop

    def test_create_idempotent(self, host_with_hostnames, test_client, session):
        """
        This test makes sure that creating the same vuln twice doesn't duplicate the entry or has any other collateral effects
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='Vulnerability name goes here',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='Description goes here',
            severity='critical',
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 409
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()

    def test_create_vuln_with_closed_status(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            status='closed',
            refs=[],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['status'] == 'closed'
        assert res.json['name'] == 'New vulns'
        assert res.json['type'] == 'Vulnerability'
        assert res.json['parent'] == host_with_hostnames.id
        assert res.json['parent_type'] == 'Host'

    def test_create_vuln_with_closed_status(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            status='closed',
            refs=[],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['status'] == 'closed'
        assert res.json['name'] == 'New vulns'
        assert res.json['type'] == 'Vulnerability'
        assert res.json['parent'] == host_with_hostnames.id
        assert res.json['parent_type'] == 'Host'

    def _create_put_data(self,
                         name, desc, status, parent, parent_type,
                         attachments=None, impact=None, refs=None,
                         policy_violations=None):
        if not refs:
            refs = []
        if not policy_violations:
            policy_violations = []

        if not impact:
            impact = {"accountability": False, "availability": False, "confidentiality": False, "integrity": False}

        raw_data = {
            "_id":"e1b45f5375facfb1435d37e182ebc22de5f77bb3.e05df1c85617fffb575d2ced2679e9a0ebda7c3e",
            "metadata":{
                "update_time":1509045001.279,
                "update_user":"",
                "update_action":0,
                "creator":"UI Web",
                "create_time":1509045001.279,
                "update_controller_action":
                    "UI Web New",
                "owner":""},
            "obj_id":"e05df1c85617fffb575d2ced2679e9a0ebda7c3e",
            "owner":"",
            "parent": parent,
            "type":"Vulnerability",
            "ws":"cloud",
            "confirmed": True,
            "data":"",
            "desc": desc,
            "easeofresolution":None,
            "impact": impact,
            "name": name,
            "owned": False,
            "policyviolations":policy_violations,
            "refs": refs,
            "resolution":"",
            "severity": "critical",
            "status": status,
            "_attachments":{},
            "description":"",
            "parent_type": parent_type,
            "protocol":"",
            "version":""}

        if attachments:
            raw_data['_attachments'] = {}
            for attachment in attachments:
                raw_data['_attachments'][attachment.name] = {
                     "content_type": "application/x-shellscript",
                     "data": b64encode(attachment.read())
                 }

        return raw_data

    def test_update_vuln_from_open_to_close(self, test_client, session, host_with_hostnames):
        vuln = self.factory.create(status='open', host=host_with_hostnames, service=None, workspace=host_with_hostnames.workspace)
        session.commit()
        raw_data = self._create_put_data(
            name='New name',
            desc='New desc',
            status='closed',
            parent=vuln.host.id,
            parent_type='Host',
            refs=['ref1'],
            policy_violations=['pv0']
        )
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.put(self.url(vuln), data=raw_data)
        assert res.status_code == 200
        assert vuln_count_previous == session.query(Vulnerability).count()
        assert res.json['status'] == 'closed'
        assert res.json['name'] == 'New name'
        assert res.json['desc'] == 'New desc'

    def test_create_vuln_web(self, host_with_hostnames, test_client, session):
        service = ServiceFactory.create(host=host_with_hostnames, workspace=host_with_hostnames.workspace)
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        vuln_web_count_previous = session.query(VulnerabilityWeb).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_web_count_previous + 1 == session.query(VulnerabilityWeb).count()
        assert vuln_count_previous  == session.query(Vulnerability).count()
        assert res.json['name'] == 'New vulns'
        assert res.json['owner'] == 'test'
        assert res.json['type'] == 'VulnerabilityWeb'
        assert res.json['parent'] == service.id
        assert res.json['parent_type'] == 'Service'
        assert res.json['method'] == 'GET'
        assert res.json['path'] == '/pepep'

    @pytest.mark.usefixtures('mock_envelope_list')
    @pytest.mark.parametrize('medium_name', ['medium', 'med'])
    def test_filter_by_severity(self, test_client, session,
                                second_workspace,
                                vulnerability_factory,
                                vulnerability_web_factory,
                                medium_name,
                                ):
        expected_ids = set()

        vulns = vulnerability_factory.create_batch(
            5, workspace=second_workspace, severity='high')
        vulns += vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, severity='high')

        medium_vulns = vulnerability_factory.create_batch(
            5, workspace=second_workspace, severity='medium')
        medium_vulns_web = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, severity='medium')
        session.add_all(vulns)
        session.add_all(medium_vulns + medium_vulns_web)
        session.commit()
        expected_ids.update(vuln.id for vuln in medium_vulns)
        expected_ids.update(vuln.id for vuln in medium_vulns_web)

        res = test_client.get(self.url(
            workspace=second_workspace) + '?severity=%s' % medium_name)
        assert res.status_code == 200
        for vuln in res.json['data']:
            assert vuln['severity'] == 'med'
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

    def test_filter_by_invalid_severity_fails(self, test_client):
        res = test_client.get(self.url() + '?severity=131231')
        assert res.status_code == 400
        assert 'Invalid severity type' in res.data

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_invalid_severity(self, test_client):
        res = test_client.get(self.url() + '?severity=invalid')
        assert res.status_code == 400

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_method(self, test_client, session, second_workspace,
                              vulnerability_factory,
                              vulnerability_web_factory):

        # Vulns that shouldn't be shown
        vulnerability_factory.create_batch(5, workspace=second_workspace)
        vulnerability_web_factory.create_batch(5, workspace=second_workspace,
                                               method='POSTT')

        # Vulns that must be shown
        expected_vulns = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, method='POST')

        session.commit()
        expected_ids = {vuln.id for vuln in expected_vulns}

        # This shouldn't show any vulns with POSTT method
        res = test_client.get(self.url(
            workspace=second_workspace) + '?method=POST')
        assert res.status_code == 200
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

        # This shouldn't show any vulns since by default method filter is
        # an exact match, not a like statement
        res = test_client.get(self.url(
            workspace=second_workspace) + '?method=%25POST%25')
        assert res.status_code == 200
        assert len(res.json['data']) == 0

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_website(self, test_client, session,
                               second_workspace,
                               vulnerability_factory,
                               vulnerability_web_factory,
                               ):

        # Vulns that shouldn't be shown
        vulnerability_factory.create_batch(5, workspace=second_workspace)
        vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, website='other.com')

        # Vulns that must be shown
        expected_vulns = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, website='faradaysec.com')
        session.commit()
        expected_ids = {vuln.id for vuln in expected_vulns}

        res = test_client.get(self.url(
            workspace=second_workspace) + '?website=faradaysec.com')
        assert res.status_code == 200

        for vuln in res.json['data']:
            assert vuln['website'] == 'faradaysec.com'
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_target(self, test_client, session, host_factory,
                              service_factory, vulnerability_factory,
                              vulnerability_web_factory):
        host = host_factory.create(workspace=self.workspace,
                                   ip='9.9.9.9')
        expected_ids = set()

        host_vulns = vulnerability_factory.create_batch(
            10, workspace=self.workspace, host=host, service=None)
        session.flush()
        expected_ids.update(v.id for v in host_vulns)

        for service in service_factory.create_batch(10,
                                                    workspace=self.workspace,
                                                    host=host):
            service_vuln = vulnerability_factory.create(
                workspace=self.workspace, service=service, host=None)
            web_vuln = vulnerability_web_factory.create(
                workspace=self.workspace, service=service)
            session.flush()
            expected_ids.add(service_vuln.id)
            expected_ids.add(web_vuln.id)

        res = test_client.get(self.url() + '?target=9.9.9.9')
        assert res.status_code == 200
        for vuln in res.json['data']:
            assert vuln['target'] == '9.9.9.9'
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_sort_by_method(self, session, test_client, second_workspace,
                            vulnerability_factory, vulnerability_web_factory):
        vulns = vulnerability_factory.create_batch(
            10, workspace=second_workspace
        )
        vulns += vulnerability_web_factory.create_batch(
            10, workspace=second_workspace, method=None
        )
        session.add_all(vulns)
        session.commit()
        for method in ('afjbeidcgh'):
            vulnerability_web_factory.create(workspace=second_workspace,
                                             method=method)

        session.commit()
        res = test_client.get(self.url(workspace=second_workspace) +
                              '?sort=method&sort_dir=asc')
        assert res.status_code == 200, res.data
        assert len(res.json['data']) == 30
        assert ''.join(v['method'] for v in res.json['data']
                       if v['method']) == 'abcdefghij'

        res = test_client.get(self.url(workspace=second_workspace) +
                              '?sort=method&sort_dir=desc')
        assert res.status_code == 200, res.data
        assert len(res.json['data']) == 30
        assert ''.join(v['method'] for v in res.json['data']
                       if v['method']) == 'abcdefghij'[::-1]

    def test_create_vuln_with_evidence(self, host_with_hostnames, test_client,
                                       session):
        session.commit()  # flush host_with_hostnames
        attachments = [
            open(os.path.join(CURRENT_PATH, 'data', 'faraday.png'), 'r'),
            open(os.path.join(CURRENT_PATH, 'data', 'test.html'), 'r')
        ]
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            attachments=attachments,
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)

        assert res.status_code == 201
        assert len(res.json['_attachments']) == 2
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        map(lambda fileobj: fileobj.close(), attachments)

    def test_create_vuln_with_refs(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=['CVE-2017-0002', 'CVE-2017-0012', 'CVE-2017-0012'],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert session.query(Reference).count() == 2
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()

    def test_create_vuln_with_policyviolations(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=['PCI DSS Credir card not encrypted',
                              'PCI DSS Credir card not encrypted'],
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert session.query(PolicyViolation).count() == 1
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()

    def test_create_vuln_imapct_verification(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            impact={
                'accountability': True,
                'availability': True,
                'confidentiality': True,
                'integrity': True
            }
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['name'] == 'New vulns'
        assert res.json['impact'] == {u'accountability': True,
                                     u'availability': True,
                                     u'confidentiality': True,
                                     u'integrity': True}

    def test_handles_invalid_impact(self, host_with_hostnames, test_client,
                                    session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            impact={
                'accountability': True,
                'integrity': 'aaaa',
                'invalid': None,
            }
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 400

    def test_create_vuln_with_invalid_type(self,
                                           host_with_hostnames,
                                           test_client,
                                           session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='VulnerabilitySarasa',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post(
            '/v2/ws/{0}/vulns/'.format(ws_name),
            data=raw_data,
        )
        assert res.status_code == 400
        assert vuln_count_previous == session.query(Vulnerability).count()
        assert res.json['message'] == 'Invalid vulnerability type.'

    def test_create_vuln_with_invalid_severity(self,
                                               host_with_hostnames,
                                               test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            severity="invalid",
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 400
        assert vuln_count_previous == session.query(Vulnerability).count()
        assert 'Invalid severity type.' in res.data

    def test_create_vuln_with_invalid_ease_of_resolution(self,
                                                         host_with_hostnames,
                                                         test_client,
                                                         session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            easeofresolution='frutafrutafruta'
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 400
        assert vuln_count_previous == session.query(Vulnerability).count()
        assert res.json['messages'].keys() == ['easeofresolution']
        assert res.json['messages']['easeofresolution'][0] == u'Not a valid choice.'

    def test_create_vuln_with_null_ease_of_resolution(self,
                                                      host_with_hostnames,
                                                      test_client,
                                                      session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            easeofresolution=None,
        )
        ws_name = host_with_hostnames.workspace.name
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name),
                               data=raw_data)
        assert res.status_code == 201, (res.status_code, res.data)
        created_vuln = Vulnerability.query.get(res.json['_id'])
        assert created_vuln.ease_of_resolution is None

    def test_count_confirmed(self, test_client, session):
        for i, vuln in enumerate(self.objects[:3]):
            vuln.confirmed = True

            # Set critical severity to first vuln, high to the others
            if i == 0:
                vuln.severity = 'critical'
            else:
                vuln.severity = 'high'

            session.add(vuln)
            session.commit()

        res = test_client.get(self.url() +
                              'count/?confirmed=1&group_by=severity')
        assert res.status_code == 200
        assert res.json['total_count'] == 3
        assert sorted(res.json['groups']) == sorted([
            {"name": "high", "severity": "high", "count": 2},
            {"name": "critical", "severity": "critical", "count": 1},
        ])

    def test_count_severity_map(self, test_client, second_workspace, session):
        vulns = self.factory.create_batch(4, severity='informational',
                                  workspace=second_workspace)
        vulns += self.factory.create_batch(3, severity='medium',
                                  workspace=second_workspace)
        vulns += self.factory.create_batch(2, severity='low',
                                  workspace=second_workspace)
        session.add_all(vulns)
        session.commit()

        res = test_client.get(self.url(workspace=second_workspace) +
                              'count/?group_by=severity')
        assert res.status_code == 200
        assert res.json['total_count'] == 9
        assert sorted(res.json['groups']) == sorted([
            {"name": "med", "severity": "med", "count": 3},
            {"name": "low", "severity": "low", "count": 2},
            {"name": "info", "severity": "info", "count": 4},
        ])

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_target(self, test_client, session, second_workspace,
                    host_factory, service_factory,
                    vulnerability_factory, vulnerability_web_factory):
        host_factory.create_batch(5, workspace=second_workspace)
        service_factory.create_batch(5, workspace=second_workspace)
        host = host_factory.create(workspace=second_workspace)
        service = service_factory.create(host=host,
                                         workspace=second_workspace)
        vulns = [
            vulnerability_factory.create(host=host, service=None,
                                         workspace=second_workspace),
            vulnerability_factory.create(service=service, host=None,
                                         workspace=second_workspace),
            vulnerability_web_factory.create(service=service,
                                             workspace=second_workspace),
        ]

        session.commit()
        res = test_client.get(self.url(workspace=second_workspace))
        assert res.status_code == 200
        for v in res.json['data']:
            assert v['target'] == host.ip

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_os(self, test_client, session, second_workspace,
                host_factory, service_factory,
                vulnerability_factory, vulnerability_web_factory):
        host_factory.create_batch(5, workspace=second_workspace)
        service_factory.create_batch(5, workspace=second_workspace)
        host = host_factory.create(workspace=second_workspace)
        service = service_factory.create(host=host,
                                         workspace=second_workspace)
        vulns = [
            vulnerability_factory.create(host=host, service=None,
                                         workspace=second_workspace),
            vulnerability_factory.create(service=service, host=None,
                                         workspace=second_workspace),
            vulnerability_web_factory.create(service=service,
                                             workspace=second_workspace),
        ]

        session.commit()
        res = test_client.get(self.url(workspace=second_workspace))
        assert res.status_code == 200
        for v in res.json['data']:
            assert v['host_os'] == host.os

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_command_id(self, test_client, session,
                                  second_workspace,
                                  workspace,
                                  vulnerability_factory,
                                  vulnerability_web_factory,
                                  ):
        expected_ids = set()
        web_expected_ids = set()
        host = HostFactory.create(workspace=second_workspace)
        service = ServiceFactory.create(workspace=second_workspace)

        command = EmptyCommandFactory.create(workspace=second_workspace)
        web_command = EmptyCommandFactory.create(workspace=second_workspace)
        high_vulns = vulnerability_factory.create_batch(
            5, workspace=second_workspace, severity='high', host=host, service=None)
        high_vulns_web = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, severity='high', service=service)
        session.commit()
        CommandObjectFactory.create(
            command=command,
            object_type='host',
            object_id=host.id,
            workspace=second_workspace
        )
        CommandObjectFactory.create(
            command=web_command,
            object_type='service',
            object_id=service.id,
            workspace=second_workspace
        )
        for high_vuln in high_vulns:

            CommandObjectFactory.create(
                command=command,
                object_type='vulnerability',
                object_id=high_vuln.id,
                workspace=second_workspace
            )
        for high_vuln_web in high_vulns_web:

            CommandObjectFactory.create(
                command=web_command,
                object_type='vulnerability',
                object_id=high_vuln_web.id,
                workspace=second_workspace
            )

        session.commit()

        expected_ids.update(vuln.id for vuln in high_vulns)
        web_expected_ids.update(vuln.id for vuln in high_vulns_web)

        res = test_client.get(self.url(
            workspace=second_workspace) + '?command_id={0}'.format(command.id))
        assert res.status_code == 200
        for vuln in res.json['data']:
            command_object = CommandObject.query.filter_by(
                object_id=vuln['_id'],
                object_type='vulnerability',
                workspace=second_workspace,
            ).first()
            vuln['metadata']['command_id'] == command_object.command.id
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

        # Check for web vulns
        res = test_client.get(self.url(
            workspace=second_workspace) + '?command_id={0}'.format(web_command.id))
        assert res.status_code == 200
        for vuln in res.json['data']:
            command_object = CommandObject.query.filter_by(
                object_id=vuln['_id'],
                object_type='vulnerability',
                workspace=second_workspace,
            ).first()
            vuln['metadata']['command_id'] == command_object.command.id
        assert set(vuln['_id'] for vuln in res.json['data']) == web_expected_ids

        # Check for cross-workspace bugs
        res = test_client.get(self.url(
            workspace=workspace) + '?command_id={0}'.format(web_command.id))
        assert res.status_code == 200
        assert len(res.json['data']) == 0

    def test_vulnerability_metadata(self, session, test_client, workspace):
        owner = UserFactory.create()
        service = ServiceFactory.create(workspace=workspace)
        command = EmptyCommandFactory.create(id=5555, workspace=workspace)
        update_command = EmptyCommandFactory.create(workspace=workspace)

        vuln = VulnerabilityWebFactory.create(
            service=service,
            creator=owner,
            workspace=workspace
        )
        session.flush()
        CommandObjectFactory.create(
            command=command,
            object_type='vulnerability',
            object_id=vuln.id,
            workspace=workspace
        )

        CommandObjectFactory.create(
            command=update_command,
            object_type='vulnerability',
            object_id=vuln.id,
            workspace=workspace
        )
        session.commit()

        res = test_client.get(self.url())
        assert res.status_code == 200
        from_json_vuln = filter(lambda raw_vuln: raw_vuln['id'] == vuln.id,
                                res.json['vulnerabilities'])
        assert 'metadata' in from_json_vuln[0]['value']
        expected_metadata = {
            u'command_id': command.id,
            u'create_time': pytz.UTC.localize(vuln.create_date).isoformat(),
            u'creator': command.tool,
            u'owner': owner.username,
            u'update_action': 0,
            u'update_controller_action': u'',
            u'update_time': pytz.UTC.localize(vuln.update_date).isoformat(),
            u'update_user': None
        }

        assert expected_metadata == from_json_vuln[0]['value']['metadata']

    @pytest.mark.parametrize("parent_type, parent_factory", [
        ("Host", HostFactory),
        ("Service", ServiceFactory),
    ], ids=["with host parent", "with service parent"])
    def test_create_with_parent_of_other_workspace(
            self, parent_type, parent_factory, test_client, session,
            second_workspace):
        parent = parent_factory.create(workspace=second_workspace)
        session.commit()
        assert parent.workspace_id != self.workspace.id
        data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=parent.id,
            parent_type=parent_type,
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        res = test_client.post(self.url(), data=data)
        assert res.status_code == 400
        assert 'Parent id not found' in res.data

    @pytest.mark.parametrize("parent_type, parent_factory", [
        ("Host", HostFactory),
        ("Service", ServiceFactory),
    ], ids=["with host parent", "with service parent"])
    def test_update_with_parent_of_other_workspace(
            self, parent_type, parent_factory, test_client, session,
            second_workspace, credential_factory):
        parent = parent_factory.create(workspace=second_workspace)
        session.add(parent)
        session.commit()
        assert parent.workspace_id != self.workspace.id
        data = self._create_put_data(
            name='New name',
            desc='New desc',
            status='closed',
            parent=parent.id,
            parent_type=parent_type,
            refs=['ref1'],
            policy_violations=['pv0']
        )
        res = test_client.put(self.url(self.first_object), data=data)
        assert res.status_code == 400
        assert 'Parent id not found' in res.data

    def test_create_vuln_multiple_times_returns_conflict(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name),
                               data=raw_data)
        assert res.status_code == 409

    def test_create_webvuln_multiple_times_returns_conflict(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        service = ServiceFactory.create(workspace=self.workspace)
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulnsweb',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name),
                               data=raw_data)
        assert res.status_code == 409

    def test_create_similar_vuln_service_and_vuln_web_conflict_succeed(
            self, service, vulnerability_factory, vulnerability_web_factory,
            session, test_client, workspace):
        service_vuln = vulnerability_factory.create(
            service=service, host=None, workspace=workspace,
            name="test conflict", description="test"
        )
        session.commit()
        old_count = VulnerabilityGeneric.query.count()
        raw_data = _create_post_data_vulnerability(
            name='test conflict',
            description='test',
            vuln_type='Vulnerability',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            severity='low',
        )
        raw_data['type'] = 'VulnerabilityWeb'
        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 201
        assert VulnerabilityGeneric.query.count() == old_count + 1

    def test_update_conflict(self, host, vulnerability_factory, session,
                             test_client):
        vulnerability_factory.create(
            workspace=self.workspace, host=host, service=None,
            name="x", description="x")
        target_vuln = vulnerability_factory.create(
            workspace=self.workspace, host=host, service=None,
            name="y", description="y")
        session.commit()
        raw_data = self._create_put_data(
            'x',
            'x',
            'open',
            host.id,
            'Host',
        )
        res = test_client.put(self.url(obj=target_vuln), data=raw_data)
        assert res.status_code == 409

    def test_create_and_update_webvuln(self, host_with_hostnames, test_client, session):
        """
            This reproduces a bug found. after creating an object with a
            command, the update caused an integrity error within the same
            command scope.
        """
        command = CommandFactory.create(workspace=self.workspace)
        service = ServiceFactory.create(workspace=self.workspace)
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulnsweb',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        res = test_client.post('/v2/ws/{0}/vulns/?command_id={1}'.format(ws_name, command.id), data=raw_data)
        assert res.status_code == 201
        raw_data = _create_post_data_vulnerability(
            name='Update vulnsweb',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            description='Update helloworld',
            severity='high',
        )
        res = test_client.put('/v2/ws/{0}/vulns/{1}/?command_id={2}'.format(ws_name, res.json['_id'], command.id),
                              data=raw_data)
        assert res.status_code == 200

    def test_create_vuln_from_command(self, test_client, session):
        command = EmptyCommandFactory.create(workspace=self.workspace)
        service = ServiceFactory.create(workspace=self.workspace)
        session.commit()
        assert len(command.command_objects) == 0
        url = self.url(workspace=command.workspace) + '?' + urlencode({'command_id': command.id})
        raw_data = _create_post_data_vulnerability(
            name='Update vulnsweb',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='high',
        )
        res = test_client.post(url, data=raw_data)

        assert res.status_code == 201
        assert len(command.command_objects) == 1
        cmd_obj = command.command_objects[0]
        assert cmd_obj.object_type == 'vulnerability'
        assert cmd_obj.object_id == res.json['_id']
        assert res.json['metadata']['creator'] == command.tool

    def test_with_invalid_id_returns_400(self, session, test_client):
        """
            Bug found on hackaton.
        """
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id='',
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 400

    def test_vuln_created_without_command_has_webui_in_metadata(self, test_client, session):
        host = HostFactory.create(workspace=self.workspace)
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 201
        assert res.json['metadata']['creator'] == 'Web UI'

    def test_invalid_host_id_error_message(self, test_client):
        """
            This test reporduces a bug when the parent_id is a string it returned
            the error message "Invalid Parent Type"
        """
        raw_data = {
            'command_id': None,
             'confirmed': False,
             'data': None,
             'desc': 'pepe',
             'description': 'pepe',
             'metadata': {
                'command_id': '',
                'create_time': 1518627247.194113,
                'creator': '',
                'owner': '',
                'update_action': 0,
                'update_controller_action': 'No model controller call',
                'update_time': 1518627247.194114,
                'update_user': ''},
             'name': 'vuln1',
             'owned': False,
             'owner': '',
             'parent': '358302',
             'parent_type': 'Host',
             'policyviolations': [],
             'refs': [],
             'resolution': '',
             'severity': 'critical',
             'status': 'opened',
             'type': 'Vulnerability'
        }

        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 400
        assert res.json == {u'messages': {u'_schema': [u'Parent id not found: 358302']}}

    def test_after_deleting_vuln_ref_and_policies_remains(self, session, test_client):
        vuln = VulnerabilityFactory.create(workspace=self.workspace)
        ref1 = ReferenceFactory.create(workspace=self.workspace)
        pv1 = PolicyViolationFactory.create(workspace=self.workspace)
        vuln.reference_instances.add(ref1)
        vuln.policy_violation_instances.add(pv1)
        session.add(vuln)
        session.commit()

        assert Reference.query.count() == 1
        assert PolicyViolation.query.count() == 1
        assert Vulnerability.query.count() == 6

        res = test_client.delete(self.url(vuln))

        assert res.status_code == 204

        assert Reference.query.count() == 1
        assert PolicyViolation.query.count() == 1
        assert Vulnerability.query.count() == 5

    def test_search_by_id(self, session, test_client):
        vuln = VulnerabilityFactory.create()
        vuln2 = VulnerabilityFactory.create(workspace=vuln.workspace)
        session.add(vuln)
        session.add(vuln2)
        session.commit()
        res = test_client.get(self.url(workspace=vuln.workspace) + '?id={0}'.format(vuln.id))
        assert res.json['count'] == 1
        assert res.json['vulnerabilities'][0]['value']['name'] == vuln.name

    def test_search_by_hostnames_service_case(self, session, test_client):
        workspace = WorkspaceFactory.create()
        vuln2 = VulnerabilityFactory.create(workspace=workspace)
        hostname = HostnameFactory.create(workspace=workspace, name='test.com')
        host = HostFactory.create(workspace=workspace)
        host.hostnames.append(hostname)
        service = ServiceFactory.create(workspace=workspace, host=host)
        vuln = VulnerabilityFactory.create(service=service, host=None, workspace=workspace)
        session.add(vuln)
        session.add(vuln2)
        session.add(service)
        session.add(hostname)
        session.commit()
        url = self.url(workspace=workspace) + '?hostnames={0}'.format(hostname.name)
        res = test_client.get(url)

        assert res.status_code == 200
        assert res.json['count'] == 1
        assert res.json['vulnerabilities'][0]['value']['name'] == vuln.name

    def test_search_by_hostnames_host_case(self, session, test_client):
        workspace = WorkspaceFactory.create()
        vuln2 = VulnerabilityFactory.create(workspace=workspace)
        hostname = HostnameFactory.create(workspace=workspace, name='test.com')
        host = HostFactory.create(workspace=workspace)
        host.hostnames.append(hostname)
        vuln = VulnerabilityFactory.create(host=host, service=None, workspace=workspace)
        session.add(vuln)
        session.add(vuln2)
        session.add(host)
        session.add(hostname)
        session.commit()
        url = self.url(workspace=workspace) + '?hostnames={0}'.format(hostname.name)
        res = test_client.get(url)
        assert res.status_code == 200
        assert res.json['count'] == 1
        assert res.json['vulnerabilities'][0]['value']['name'] == vuln.name

    def test_hostnames_comma_separated(self, test_client, session):
        #Create Host A with hostname HA
        hostnameA = HostnameFactory.create()
        hostnameA.host.workspace = hostnameA.workspace
        #Create Host B with hostname HB
        hostnameB = HostnameFactory.create(workspace=hostnameA.workspace)
        hostnameB.host.workspace = hostnameA.workspace
        #Create Vuln with Host A
        vuln = VulnerabilityFactory.create(host=hostnameA.host, workspace=hostnameA.workspace)
        #Create Vuln with Host B
        vuln2 = VulnerabilityFactory.create(host=hostnameB.host, workspace=hostnameA.workspace)
        session.add(hostnameA)
        session.add(hostnameB)
        session.add(vuln)
        session.add(vuln2)
        session.commit()

        #Search with hosnames=HA,HB
        res = test_client.get(self.url(workspace=vuln.workspace) + '?hostname={0},{1}'.format(hostnameA,hostnameB))
        assert res.status_code == 200
        assert res.json['count'] == 2

    def test_missing_policy_violation_case(self, test_client, session):
        """
            bug found when a json was missing the policyviolations key
        """
        host = HostFactory.create(workspace=self.workspace)
        session.commit()
        data = {
             'name': 'Test Alert policy_violations',
             'severity': 'informational',
             'creator': 'Zap',
             'parent_type': 'Host',
             'parent': host.id,
             'type': 'Vulnerability',
             'refs': ''
        }
        res = test_client.post(self.url(), data=data)
        assert res.status_code == 201

    def test_missing_references_case(self, test_client, session):
        """
            bug found when a json was missing the policyviolations key
        """
        host = HostFactory.create(workspace=self.workspace)
        session.commit()
        data = {
             'name': 'Test Alert policy_violations',
             'severity': 'informational',
             'creator': 'Zap',
             'parent_type': 'Host',
             'parent': host.id,
             'type': 'Vulnerability',
        }
        res = test_client.post(self.url(), data=data)
        assert res.status_code == 201


def test_type_filter(workspace, session,
                     vulnerability_factory,
                     vulnerability_web_factory):
    filter_ = VulnerabilityFilterSet().filters['type']
    std_vulns = vulnerability_factory.create_batch(10, workspace=workspace)
    web_vulns = vulnerability_web_factory.create_batch(10, workspace=workspace)
    session.add_all(std_vulns)
    session.add_all(web_vulns)
    session.commit()

    std_filter = filter_.filter(VulnerabilityGeneric.query,
                                VulnerabilityGeneric,
                                'type',
                                'Vulnerability'
                                )
    assert {v.id for v in std_filter} == {v.id for v in std_vulns}

    web_filter = filter_.filter(VulnerabilityGeneric.query,
                                VulnerabilityGeneric,
                                'type',
                                'VulnerabilityWeb'
                                )
    assert {v.id for v in web_filter} == {v.id for v in web_vulns}


def test_creator_filter(workspace, session,
                        empty_command_factory, command_object_factory,
                        vulnerability_factory, vulnerability_web_factory):
    filter_ = VulnerabilityFilterSet().filters['creator']
    std_vulns = vulnerability_factory.create_batch(10,
                                                   workspace=workspace)[:5]
    web_vulns = vulnerability_web_factory.create_batch(10,
                                                       workspace=workspace)[:5]
    command = empty_command_factory.create(workspace=workspace,
                                           tool="metasploit")

    vulns = std_vulns + web_vulns
    session.add_all(vulns)
    session.commit()
    session.flush()
    for vuln in vulns:
        command_object_factory.create(command=command,
                                      object_type='vulnerability',
                                      object_id=vuln.id,
                                      workspace=workspace)
    session.commit()

    filtered = filter_.filter(VulnerabilityGeneric.query,
                              VulnerabilityGeneric,
                              'creator',
                              'metasp')
    assert {v.id for v in filtered} == {v.id for v in vulns}


def test_service_filter(workspace, session, host, service_factory,
                        vulnerability_factory, vulnerability_web_factory):
    filter_ = VulnerabilityFilterSet().filters['service']

    vulnerability_factory.create_batch(5, host=host, service=None,
                                       workspace=workspace)
    other_service = service_factory.create(name='ftp', workspace=workspace)
    vulnerability_factory.create_batch(10, host=None, service=other_service,
                                       workspace=workspace)
    vulnerability_web_factory.create_batch(10, service=other_service,
                                           workspace=workspace)

    service = service_factory.create(name='http', workspace=workspace)
    vulns = []
    vulns = vulnerability_factory.create_batch(10, host=None, service=service,
                                               workspace=workspace)
    vulns += vulnerability_web_factory.create_batch(10, service=service,
                                                    workspace=workspace)
    session.commit()

    filtered = filter_.filter(VulnerabilityGeneric.query,
                              VulnerabilityGeneric,
                              'service',
                              'http')
    assert all(v.service and v.service.name == 'http'
               for v in filtered)
    assert {v.id for v in filtered} == {v.id for v in vulns}


def test_name_filter(workspace, session, host, vulnerability_factory):
    """Test case insensitivity and partial match detection"""
    filter_ = VulnerabilityFilterSet().filters['name']
    vulnerability_factory.create_batch(5, host=host, workspace=workspace)
    expected_vulns = vulnerability_factory.create_batch(
        5, host=host, workspace=workspace, name="Old OpenSSL version")
    for vuln in expected_vulns:
        session.add(vuln)
    session.commit()
    filtered = filter_.filter(VulnerabilityGeneric.query,
                              VulnerabilityGeneric,
                              'name',
                              'openssl')
    assert {v.id for v in filtered} == {v.id for v in expected_vulns}


def vulnerability_json(parent_id, parent_type):
    return st.fixed_dictionaries(
        {
        'metadata': st.fixed_dictionaries({
            'update_time': st.floats(),
            'update_user': st.one_of(st.none(), st.text()),
            'update_action': st.integers(),
            'creator': st.text(),
            'create_time': st.floats(),
            'update_controller_action': st.text(),
            'owner': st.one_of(st.none(), st.text())}),
        'obj_id': st.integers(),
        'owner': st.one_of(st.none(), st.text()),
        'parent': st.sampled_from([parent_id]),
        'parent_type': st.sampled_from([parent_type]),
        'type': st.one_of(
            st.sampled_from([
            "Vulnerability", "Invalid", None]),
            st.text()
        ),
        'ws': st.one_of(st.none(), st.text()),
        'confirmed': st.booleans(),
        'data': st.one_of(st.none(), st.text()),
        'desc': st.one_of(st.none(), st.text()),
        'easeofresolution': st.sampled_from(['trivial',
            'simple',
            'moderate',
            'difficult',
            'infeasible']),
        'impact': st.fixed_dictionaries({'accountability': st.booleans(), 'availability': st.booleans(),
                  'confidentiality': st.booleans(),
                  'integrity': st.booleans()}),
        'name': st.one_of(st.none(), st.text()),
        'owned': st.booleans(),
        'policyviolations': st.lists(st.one_of(st.none(), st.text())),
        'refs': st.lists(st.one_of(st.none(), st.text())),
        'resolution': st.one_of(st.none(), st.text()),
        'severity': st.sampled_from(['critical',
            'high',
            'med',
            'medium',
            'low',
            'informational',
            'unclassified']),
        'status': st.sampled_from(['open',
            'closed',
            're-opened',
            'risk-accepted']),
        '_attachments': st.fixed_dictionaries({}),
        'description': st.one_of(st.none(), st.text()),
        'protocol': st.one_of(st.none(), st.text()),
        'version': st.one_of(st.none(), st.text())})


@pytest.mark.usefixtures('logged_user')
@pytest.mark.hypothesis
def test_hypothesis(host_with_hostnames, test_client, session):
    session.commit()
    VulnerabilityData = vulnerability_json(host_with_hostnames.id, 'Host')

    @given(VulnerabilityData)
    def send_api_request(raw_data):

        ws_name = host_with_hostnames.workspace.name
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name),
                               data=raw_data)
        assert res.status_code in [201, 400, 409]

    send_api_request()


def test_model_converter():
    """Test that string fields are translated to NullToBlankString
    fields"""
    # Generic test. Think twice if you want to delete this
    field = VulnerabilitySchema().fields['data']
    print field
    assert isinstance(field, NullToBlankString)
    assert field.allow_none
