<!-- Faraday Penetration Test IDE &#45; Community Version -->
<!-- Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/) -->
<!-- See the file 'doc/LICENSE' for the license information -->
<!DOCTYPE html>   
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
    <meta charset="utf-8"/>
    <!--[if IE]><![endif]-->
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>Status Report | Faraday</title>
    <meta name="description" content=""/>
    <meta name="keywords" content=""/>
    <meta name="author" content=""/>

    <!-- !CSS -->
    <link rel="stylesheet" type="text/css" href="normalize.css" />
    <link rel="stylesheet" type="text/css" href="estilos.css" />
    <link rel="stylesheet" type="text/css" href="script/jquery.qtip.css" />
    <link rel="stylesheet" href="script/bootstrap.min.css">
    <link rel="stylesheet" href="script/bootstrap-theme.min.css">
    <link href="favicon.ico" rel="shortcut icon">
    <link href="favicon.ico" type="image/vnd.microsoft.icon" rel="icon" />
    <link href="images/site_preview.jpg" rel="image_src" />

    <script type="text/javascript" src="/_utils/script/jquery.js"></script>
    <script type="text/javascript" src="/_utils/script/jquery.couch.js"></script>
    <script type="text/javascript" src="script/bootstrap.min.js"></script>
    <script type="text/javascript" src="script/angular.js"></script>
    <script type="text/javascript" src="script/angular-route.js"></script>
    <script type="text/javascript" src="script/angular-selection-model.js"></script>
    <script type="text/javascript" src="script/ui-bootstrap-tpls-0.11.2.min.js"></script>
    <script type="text/javascript" src="script/jquery.qtip.js"></script>
    <script type="text/javascript" src="script/cryptojs-sha1.js"></script>
</head>

<body ng-app="status-report">
    <div id="cont">
        <div class="wrapper">
            <header class="head">
                <a href="#" class="ws-dashboard"><img class="logo" src="images/logo-faraday.png" alt="Faraday home | WS Dashboard"/></a>
            </header>
            
            <div ng-view></div>
        </div><!--!/#wrapper -->
    </div><!--!/#container -->

    <script type="text/javascript">
        $.ajaxSetup({
            async: false
        });

        var statusReport = angular.module('status-report', ['ngRoute', 'selectionModel', 'ui.bootstrap'])
            .constant("BASEURL", (function() {
                var url = window.location.origin + "/";
                return url;
            })())
            .controller('workspacesCtrl', ['$scope', 'workspacesFact', function($scope, workspacesFact) {
                workspacesFact.get(function(wss) {
                    $scope.wss = wss;
                });
            }])
            .controller('statusReportCtrl', 
                            ['$scope', '$filter', '$route', '$routeParams', '$modal', '$log', 'statusReportFact', 
                            function($scope, $filter, $route, $routeParams, $modal, $log, statusReportFact) {
                $scope.$log = $log;
                $scope.sortField = 'date';
                $scope.reverse = true;
                // load all workspaces
                statusReportFact.getWorkspaces(function(wss) {
                    $scope.workspaces = wss;
                });
                // current workspace
                $scope.workspace = $routeParams.wsId;
                // load all vulnerabilities
                $scope.vulns = statusReportFact.getVulns($scope.workspace);

                // toggles column show property
                $scope.toggleShow = function(column, show) {
                    $scope.columns[column] = !show;
                };
                
                // set columns to show and hide by default
                $scope.columns = {
                    "data":     true,
                    "date":     true,
                    "desc":     true,
                    "method":   false,
                    "name":     true,
                    "params":   false,
                    "path":     false,
                    "pname":    false,
                    "query":    false,
                    "request":  false,
                    "response": false,
                    "severity": true,
                    "status":   true,
                    "target":   true,
                    "web":      true,
                    "website":  false
                };

                $scope.severities = [
                    "unclassified",
                    "info",
                    "low",
                    "med",
                    "high"
                ];

                // returns scope vulns as CSV obj
                $scope.toCSV = function() {
                    var content = "\"Date\", \"Web\", \"Status\", \"Severity\", "+
                        "\"Name\", \"Target\", \"Description\" \n";
                    
                    $scope.vulns.forEach(function(v) {
                        content += "\""+v.date+"\","+
                            " \""+v.web+"\","+
                            " \"Vulnerable\","+
                            " \""+v.severity+"\","+
                            " \""+v.name+"\","+
                            " \""+v.target+"\","+
                            " \""+v.desc.replace(/\n[ ]*\n/g, "").replace(/\"/g, "'") +"\""+
                            "\n";
                    });

                    var obj = {
                        "title":    "SR-" + $scope.workspace,
                        "content":  content
                    };
                    
                    return obj;
                };

                // deletes all vulns with selected == true
                $scope.remove = function() {
                    var selected = false;

                    $scope.vulns.forEach(function(v) {
                        if(v.selected) selected = true;
                    });

                    if(selected) {
                        var old = $scope.vulns;
                        $scope.vulns = [];

                        old.forEach(function(v) {
                            if(v.selected) {
                                statusReportFact.removeVulns($scope.workspace, v);
                            } else {
                                $scope.vulns.push(v);
                            }
                        });
                    } else {
                        var modal = $modal.open({
                            templateUrl: 'partials/modal-ko.html',
                            controller: 'modalKoCtrl',
                            resolve: {
                                msg: function() {
                                    return 'At least one vulnerabilty must be selected in order to delete';
                                }
                            }
                        });
                    }
                };

                // updates all vulns with selected == true
                $scope.update = function(data) {
                    $scope.vulns = [];
                    
                    data.vulns.forEach(function(v) {
                        if(v.selected) {
                            if(typeof(data.severity) == "string") v.severity = data.severity;
                            if(typeof(data.name) != "undefined") v.name = data.name;
                            if(typeof(data.desc) != "undefined") v.desc = data.desc;
                            if(typeof(data.datatext) != "undefined") v.data.text = data.datatext;
                            if(v.web) {
                                if(typeof(data.method) != "undefined") v.method = data.method;
                                if(typeof(data.params) != "undefined") v.params = data.params;
                                if(typeof(data.path) != "undefined") v.path = data.path;
                                if(typeof(data.pname) != "undefined") v.pname = data.pname;
                                if(typeof(data.query) != "undefined") v.query = data.query;
                                if(typeof(data.request) != "undefined") v.request = data.request;
                                if(typeof(data.response) != "undefined") v.response = data.response;
                                if(typeof(data.website) != "undefined") v.website = data.website;
                            }
                    
                            statusReportFact.putVulns($scope.workspace, v, function(rev) {
                                v.rev = rev;
                            });
                            v.selected = false;
                        }
                        $scope.vulns.push(v);
                    });
                };

                $scope.edit = function() {
                    var selected = false;

                    $scope.vulns.forEach(function(v) {
                        if(v.selected) selected = true;
                    });

                    if(selected) {
                        var modal = $modal.open({
                            templateUrl: 'partials/modal-edit.html',
                            controller: 'modalEditCtrl',
                            size: 'lg',
                            resolve: {
                                severities: function() {
                                    return $scope.severities;
                                },
                                vulns: function() {
                                    return $scope.vulns;
                                }
                            }
                        });

                        modal.result.then(function(data) {
                            $scope.update(data);
                        });
                    } else {
                        var modal = $modal.open({
                            templateUrl: 'partials/modal-ko.html',
                            controller: 'modalKoCtrl',
                            resolve: {
                                msg: function() {
                                    return 'At least one vulnerabilty must be selected in order to edit';
                                }
                            }
                        });
                    }
                };

                $scope.checkAll = function() {
                    if(!$scope.selectall) {
                        $scope.selectall = true;
                    } else {
                        $scope.selectall = false;
                    }

                    angular.forEach($filter('filter')($scope.vulns, $scope.query), function(v) {
                        v.selected = $scope.selectall;
                    });
                };
            }])
            .controller('modalEditCtrl', function($scope, $modalInstance, severities, vulns) {
                $scope.severities = severities;
                $scope.vulns = vulns;
                $scope.web = false;

                $scope.vulns.forEach(function(v) {
                    if(v.selected && v.type === "VulnerabilityWeb") $scope.web = true; 
                });

                $scope.isChecked = function(i) {
                    return i.selected;
                };

                $scope.ok = function() {
                    var res = {};

                    if($scope.web) { 
                        res = {
                            "datatext": $scope.datatext,
                            "desc":     $scope.desc,
                            "method":   $scope.method,
                            "name":     $scope.name, 
                            "params":   $scope.params,
                            "path":     $scope.path,
                            "pname":    $scope.pname,
                            "query":    $scope.query,
                            "request":  $scope.request,
                            "response": $scope.response,
                            "severity": $scope.severitySelection, 
                            "vulns":    $scope.vulns, 
                            "website":  $scope.website
                        };    
                    } else {
                        res = {
                            "datatext": $scope.datatext,
                            "desc":     $scope.desc,
                            "name":     $scope.name, 
                            "severity": $scope.severitySelection, 
                            "vulns":    $scope.vulns 
                        };
                    }

                    $modalInstance.close(res);
                };

                $scope.cancel = function() {
                    $modalInstance.dismiss('cancel');
                };

            })
            .controller('modalKoCtrl', function($scope, $modalInstance, msg) {
                $scope.msg = msg;

                $scope.ok = function() {
                    $modalInstance.close();
                };
            })
            .factory('workspacesFact', ['BASEURL', '$http', function(BASEURL, $http) {
                var workspacesFact = {};

                workspacesFact.get = function(callback) {

                    var url = BASEURL + "_all_dbs";
                    $http.get(url).success(function(d, s, h, c) {
                        var wss = d.filter(function(ws) {
                            return ws.search(/^_/) < 0 && ws.search("reports") < 0;
                        });
                        callback(wss);
                    });
                };

                return workspacesFact;
            }])
            .factory('statusReportFact', ['vulnsFact', 'vulnsWebFact', 'hostsFact', 'workspacesFact', function(vulnsFact, vulnsWebFact, hostsFact, wsFact) {
                var statusReportFact = {};

                statusReportFact.getVulns = function(ws) {
                    var vulns       = vulnsFact.get(ws);
                    var vulnsWeb    = vulnsWebFact.get(ws);
                    var hosts       = hostsFact.get(ws);
                    vulns.forEach(function(element, index, array) {
                        element.target = hosts[element.parent].name;
                    });
                    vulnsWeb.forEach(function(element, index, array) {
                        element.target = hosts[element.parent].name;
                    });
                    return vulnsWeb.concat(vulns);
                };

                statusReportFact.putVulns = function(ws, vuln, callback) {
                    if(vuln.web) {
                        vulnsWebFact.put(ws, vuln, callback);
                    } else {
                        vulnsFact.put(ws, vuln, callback);
                    }
                };

                statusReportFact.removeVulns = function(ws, vuln) {
                    vulnsFact.remove(ws, vuln);
                };

                statusReportFact.getWorkspaces = function(callback) {
                    wsFact.get(callback);
                };

                return statusReportFact;
            }])
            .factory('vulnsFact', ['BASEURL', '$http', 'notesFact', function(BASEURL, $http, notesFact) {
                var vulnsFact = {};

                vulnsFact.get = function(ws) {
                    var vulns = [];
                    var note = {};
                    vulns_url = BASEURL + ws +"/_design/vulns/_view/vulns";
                    // gets vulns json from couch
                    $.getJSON(vulns_url, function(data) {
                        $.each(data.rows, function(n, obj){
                            var d = new Date(0); 
                            d.setUTCSeconds(obj.value.date);
                            d = d.getDate() + "/" + d.getMonth() + "/" + d.getFullYear();
                            var notes = notesFact.getNotes(ws, obj.id);
                            notes.forEach(function(n) {
                                if(n.name === "data") note = n;
                            });
                            var v = {
                                "id":           obj.id,
                                "rev":          obj.value.rev,
                                "desc":         obj.value.desc,
                                "data":         note,
                                "meta":         obj.value.meta,
                                "date":         d, 
                                "name":         obj.value.name, 
                                "oid":          obj.value.oid,
                                "owned":        obj.value.owned,
                                "owner":        obj.value.owner,
                                "parent":       obj.key.substring(0, obj.key.indexOf('.')),
                                "couch_parent": obj.value.parent,
                                "refs":         obj.value.refs,
                                "severity":     obj.value.severity,
                                "type":         obj.value.type, 
                                "web":          false,
                                "selected":     false,
                                "delete":       false
                            };
                            vulns.push(v);
                        });
                    });
                    return vulns;
                }

                vulnsFact.put = function(ws, vuln, callback) {
                    var url = BASEURL + ws + "/" + vuln.id;
                    var v = {
                        "_rev":         vuln.rev,
                        "desc":         vuln.desc, 
                        "metadata":     vuln.meta,
                        "name":         vuln.name, 
                        "obj_id":       vuln.oid,
                        "owned":        vuln.owned,
                        "owner":        vuln.owner,
                        "parent":       vuln.couch_parent, 
                        "refs":         vuln.refs,
                        "severity":     vuln.severity, 
                        "type":         vuln.type
                    };
                    $http.put(url, v).success(function(d, s, h, c) {
                        callback(d.rev);
                        console.log(vuln); 
                        notesFact.putNote(ws, "data", vuln.id, vuln.data.text);
                    });
                };

                vulnsFact.remove = function(ws, vuln) {
                    var url = BASEURL + ws + "/" + vuln.id + "?rev=" + vuln.rev;
                    $http.delete(url).success(function(d, s, h, c) {
                        console.log(d);
                    });
                };

                return vulnsFact;
            }])
            .factory('vulnsWebFact', ['BASEURL', '$http', 'notesFact', function(BASEURL, $http, notesFact) {
                var vulnsWebFact = {};

                vulnsWebFact.get = function(ws) {
                    var vulns = [];
                    var note = {};
                    vulns_url = BASEURL + ws +"/_design/vulns/_view/web";
                    // gets vulns json from couch
                    $.getJSON(vulns_url, function(data) {
                        $.each(data.rows, function(n, obj){
                            var d = new Date(0); 
                            d.setUTCSeconds(obj.value.date);
                            d = d.getDate() + "/" + d.getMonth() + "/" + d.getFullYear();
                            var notes = notesFact.getNotes(ws, obj.id);
                            notes.forEach(function(n) {
                                if(n.name === "data") note = n;
                            });
                            var v = {
                                "id":           obj.id,
                                "rev":          obj.value.rev,
                                "desc":         obj.value.desc, 
                                "meta":         obj.value.meta,
                                "date":         d, 
                                "data":         note,
                                "name":         obj.value.name, 
                                "oid":          obj.value.oid,
                                "owned":        obj.value.owned,
                                "owner":        obj.value.owner,
                                "parent":       obj.key.substring(0, obj.key.indexOf('.')),
                                "couch_parent": obj.value.parent,
                                "refs":         obj.value.refs,
                                "severity":     obj.value.severity,
                                "type":         obj.value.type, 
                                "web":          true,
                                "selected":     false,
                                "delete":       false,
                                /*** specific fields of web vulns ***/
                                "method":       obj.value.method,
                                "params":       obj.value.params,
                                "path":         obj.value.path,
                                "pname":        obj.value.pname,
                                "query":        obj.value.query,
                                "request":      obj.value.request,
                                "response":     obj.value.response,
                                "website":      obj.value.website
                            };
                            vulns.push(v);
                        });
                    });
                    return vulns;
                }

                vulnsWebFact.put = function(ws, vuln, callback) {
                    var url = BASEURL + ws + "/" + vuln.id;
                    var v = {
                        "_rev":         vuln.rev,
                        "desc":         vuln.desc, 
                        "metadata":     vuln.meta,
                        "name":         vuln.name, 
                        "obj_id":       vuln.oid,
                        "owned":        vuln.owned,
                        "owner":        vuln.owner,
                        "parent":       vuln.couch_parent, 
                        "refs":         vuln.refs,
                        "severity":     vuln.severity, 
                        "type":         vuln.type,
                        /*** specific fields of web vulns ***/
                        "method":       vuln.method,
                        "params":       vuln.params,
                        "path":         vuln.path,
                        "pname":        vuln.pname,
                        "query":        vuln.query,
                        "request":      vuln.request,
                        "response":     vuln.response,
                        "website":      vuln.website
                    };
                    $http.put(url, v).success(function(d, s, h, c) {
                        callback(d.rev);
                        notesFact.putNote(ws, "data", vuln.id, vuln.data.text);
                    });
                };

                vulnsWebFact.remove = function(ws, vuln) {
                    var url = BASEURL + ws + "/" + vuln.id + "?rev=" + vuln.rev;
                    $http.delete(url).success(function(d, s, h, c) {
                        console.log(d);
                    });
                };

                return vulnsWebFact;
            }])
            .factory('hostsFact', ['BASEURL', function(BASEURL) {
                var hostsFact = {};

                hostsFact.get = function(ws) {
                    hosts_url = BASEURL + ws + "/_design/hosts/_view/hosts";
                    var hosts = [];
                    //gets hosts json from couch
                    $.getJSON(hosts_url, function(data) {
                        $.each(data.rows, function(n, obj) {
                           hosts[obj.id] = {"name": obj.value.name, "os": obj.value.os, "owned": obj.value.owned};
                        }); 
                    });
                    return hosts;
                }
                return hostsFact;
            }])
            .factory('notesFact', ['BASEURL', '$http', function(BASEURL, $http) {
                var notesFact = {};

                notesFact.getNotes = function(ws, parent) {
                    var noteIds = [];
                    var notes = [];
                    var note = {};
                    var params = JSON.stringify([parent, "Note"]);
                    var url = BASEURL + ws + "/_design/mapper/_view/byparentandtype?key=" + params;
                    $.getJSON(url, function(data) {
                        $.each(data.rows, function(n, obj) {
                            noteIds.push(obj.value);
                        });
                    });
                    noteIds.forEach(function(id) {
                        url = BASEURL + ws + "/" + id;
                        $.getJSON(url, function(data) {
                            note = {
                                "id":   data._id,
                                "rev":  data._rev,
                                "name": data.name,
                                "text": data.text
                            };
                            notes.push(note);
                        });
                    });
                    return notes;
                };

                // updates note if existing, creates otherwise
                notesFact.putNote = function(ws, name, parent, text) {
                    var notes   = notesFact.getNotes(ws, parent);
                    var note    = {};
                    var exists  = false;
                    var url     = BASEURL + ws + "/";
                    var id      = "";
                    var rev     = "";

                    // we need to check the name fits before updating
                    if(notes.length) {
                        notes.forEach(function(note) {
                            if(note.name === name) {
                                id      = note.id;
                                rev     = note.rev;
                                url     += note.id;
                                exists  = true;
                            }
                        });
                    }

                    if(!exists) {
                        // insert
                        id = parent + "." + CryptoJS.SHA1("Message").toString();
                        url += id;
                        note = {
                            "name":     name,
                            "parent":   parent,
                            "owned":    false,
                            "text":     text,
                            "type":     "Note"
                        };
                    } else {
                        // update
                        note = {
                            "_id":      id,
                            "_rev":     rev,
                            "name":     name,
                            "parent":   parent,
                            "owned":    false,
                            "text":     text,
                            "type":     "Note"
                        };
                    }

                    //$http.put(url, note).success(function(d, a, b, c) { console.log(d); });
                    $http.put(url, note);
                };

                return notesFact;
            }])
            // CSV export
            .factory('$blob', function() {
              return {
                csvToURL: function(content) {
                  var blob;
                  blob = new Blob([content], {type: 'text/csv'});
                  return (window.URL || window.webkitURL).createObjectURL(blob);
                },
                sanitizeCSVName: function(name) {
                  if (/^[A-Za-z0-9]+\.csv$/.test(name)) {
                    return name;
                  }
                  if (/^[A-Za-z0-9]+/.test(name)) {
                    return name + ".csv";
                  }
                  throw new Error("Invalid title fo CSV file : " + name);
                },
                revoke: function(url) {
                  return (window.URL || window.webkitURL).revokeObjectURL(url);
                }
              };
            })
            // CSV export
            .factory('$click', function() {
              return {
                on: function(element) {
                  var e = document.createEvent("MouseEvent");
                  e.initMouseEvent("click", false, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                  element.dispatchEvent(e);
                }
              };
            })
            // CSV export
            .directive('downloadCsv', function($parse, $click, $blob, $log, $timeout) {
              return {
                compile: function($element, attr) {
                  var fn = $parse(attr.downloadCsv);
                   
                  return function(scope, element, attr) {
                     
                    element.on('click', function(event) {
                      var a_href, content, title, url, _ref;
                      _ref = fn(scope), content = _ref.content, title = _ref.title;
                       
                      if (!(content != null) && !(title != null)) {
                        $log.warn("Invalid content or title in download-csv : ", content, title);
                        return;
                      }
                       
                      title = $blob.sanitizeCSVName(title);
                      url = $blob.csvToURL(content);
                       
                      element.append("<a download=\"" + title + "\" href=\"" + url + "\"></a>");
                      a_href = element.find('a')[0];
                       
                      $click.on(a_href);
                      $timeout(function() {$blob.revoke(url);});
                       
                      element[0].removeChild(a_href);
                    });
                  };
                }
              };
            })
            .directive('textCollapse', ['$compile', function($compile) {
                return {
                    restrict: 'A',
                    replace: true,
                    link: function(scope, element, attrs) {
                        // start collapsed
                        scope.collapsed = false;

                        // create the function to toggle the collapse
                        scope.toggle = function() {
                            scope.collapsed = !scope.collapsed;
                        };

                        // wait for changes on the text
                        attrs.$observe('textCollapseText', function(text) {
                            // and get the maxLength
                            var maxLength = scope.$eval(attrs.textCollapseMaxLength);

                            if(text.length > maxLength) {
                                // split the text in two parts, the first always showing
                                var firstPart = String(text).substring(0, maxLength);
                                var secondPart = String(text).substring(maxLength, text.length);

                                // create some new html elements to hold the separate info
                                var firstSpan = $compile('<span>' + firstPart + '</span>')(scope);
                                var secondSpan = $compile('<span ng-if="collapsed">' + secondPart + '</span>')(scope);
                                var moreIndicatorSpan = $compile('<span ng-if="!collapsed">...</span>')(scope);
                                var toggleButton = $compile('<span selection-model-ignore class="collapse-text-toggle" ng-click="toggle()"> <a href="" selection-model-ignore>{{collapsed ? "less" : "more"}}</a></span>')(scope);

                                // remove the current contents of the element
                                // and add the new ones we created
                                element.empty();
                                element.append(firstSpan);
                                element.append(secondSpan);
                                element.append(moreIndicatorSpan);
                                element.append(toggleButton);
                            } else {
                                element.empty();
                                element.append(text);
                            }
                        });
                    }
                };
            }]);
            statusReport.config(['$routeProvider', function($routeProvider) {
                $routeProvider.
                    when('/ws/:wsId', {
                        templateUrl: 'partials/status_report.html',
                        controller: 'statusReportCtrl'
                    }).
                    when('/', {
                        templateUrl: 'partials/workspaces.html',
                        controller: 'workspacesCtrl'
                    }).
                    otherwise({
                        templateUrl: 'partials/status_report.html',
                        controller: 'statusReportCtrl'
                    });
            }]);
    </script>
</body>
</html> 
